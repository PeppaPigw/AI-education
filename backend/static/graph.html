<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>知识图谱可视化</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
        color: #2c3e50;
        overflow: hidden;
        height: 100vh;
      }

      #controls {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        background: #ffffff;
        color: #2c3e50;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
        border: 1px solid #e0e6ed;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .btn:hover {
        background: #f8fafc;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      }

      .btn.active {
        background: #3b82f6;
        color: #ffffff;
      }

      #graph-container {
        width: 100vw;
        height: 100vh;
      }

      #graph-container svg {
        width: 100%;
        height: 100%;
      }

      .node {
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .node:hover {
        filter: brightness(1.1);
      }

      .node circle {
        stroke: #ffffff;
        stroke-width: 3px;
      }

      .node.selected circle {
        stroke: #a5cbff;
        stroke-width: 5px;
      }

      .node text {
        fill: #000000;
        font-weight: 600;
        text-anchor: middle;
        pointer-events: none;
        user-select: none;
      }

      .expand-indicator {
        cursor: pointer;
      }

      .link {
        stroke: #94a3b8;
        stroke-width: 2px;
        fill: none;
        opacity: 0.4;
      }

      .relation-link {
        stroke: #a855f7;
        stroke-width: 2.5px;
        fill: none;
        opacity: 0.6;
      }

      .relation-link.hidden {
        display: none;
      }

      .relation-label {
        font-size: 11px;
        fill: #7c3aed;
        font-weight: 600;
        pointer-events: none;
        text-anchor: middle;
      }

      .relation-label.hidden {
        display: none;
      }

      #description-panel {
        position: fixed;
        bottom: 20px;
        right: 20px;
        max-width: 400px;
        max-height: 300px;
        padding: 24px;
        background: #ffffff;
        border-radius: 16px;
        border: 1px solid #e0e6ed;
        display: none;
        overflow-y: auto;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      }

      #description-panel.show {
        display: block;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      #description-panel h3 {
        color: #3b82f6;
        margin-bottom: 12px;
        font-size: 18px;
        font-weight: 600;
      }

      #description-panel p {
        color: #4b5563;
        line-height: 1.6;
        font-size: 14px;
      }

      #stats {
        position: fixed;
        bottom: 20px;
        left: 20px;
        padding: 12px 16px;
        background: #ffffff;
        border-radius: 8px;
        border: 1px solid #e0e6ed;
        font-size: 12px;
        color: #6b7280;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      #description-panel::-webkit-scrollbar {
        width: 6px;
      }

      #description-panel::-webkit-scrollbar-track {
        background: #f3f4f6;
        border-radius: 3px;
      }

      #description-panel::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <button class="btn" onclick="expandAll()">展开全部</button>
      <button class="btn" onclick="collapseAll()">折叠全部</button>
      <button class="btn" id="relationBtn" onclick="toggleRelations()">
        隐藏关系
      </button>
    </div>

    <div id="graph-container"></div>

    <div id="description-panel">
      <h3 id="node-title"></h3>
      <p id="node-description"></p>
    </div>

    <div id="stats">
      节点总数: <span id="total-nodes">0</span> | 显示节点:
      <span id="visible-nodes">0</span>
    </div>

    <script>
      let data = null;
      let allNodesData = {};
      let expandedNodes = new Set();
      let showRelations = true;
      let selectedNode = null;
      let svg, g, simulation;

      const width = window.innerWidth;
      const height = window.innerHeight;
      const centerX = width / 2;
      const centerY = height / 2;

      const levelColors = [
        "#3b82f6", // 蓝色 - Level 0
        "#8b5cf6", // 紫色 - Level 1
        "#ec4899", // 粉色 - Level 2
        "#f59e0b", // 橙色 - Level 3
        "#10b981", // 绿色 - Level 4
        "#06b6d4", // 青色 - Level 5
        "#f43f5e", // 红色 - Level 6+
      ];

      function initSVG() {
        d3.select("#graph-container").selectAll("*").remove();

        svg = d3
          .select("#graph-container")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        svg
          .append("defs")
          .append("marker")
          .attr("id", "arrowhead")
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 25)
          .attr("refY", 0)
          .attr("markerWidth", 8)
          .attr("markerHeight", 8)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M0,-5L10,0L0,5")
          .attr("fill", "#a855f7");

        g = svg.append("g");

        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 4])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          });

        svg.call(zoom);
      }

      // 自动加载 JSON 文件
      function loadJSON() {
        fetch("/static/graph.json")
          .then((response) => {
            if (!response.ok) {
              throw new Error("网络响应失败");
            }
            return response.json();
          })
          .then((jsonData) => {
            data = jsonData;
            processData();
          })
          .catch((error) => {
            console.error("JSON 加载错误:", error);
            alert("JSON 加载错误: " + error.message);
          });
      }

      // 页面加载完成后自动加载数据
      window.addEventListener("DOMContentLoaded", () => {
        loadJSON();
      });

      function buildNodeTree(nodeList) {
        allNodesData = {};
        const childrenMap = {};

        nodeList.forEach((node) => {
          allNodesData[node.id] = node;
          if (!childrenMap[node.parentId]) {
            childrenMap[node.parentId] = [];
          }
          childrenMap[node.parentId].push(node);
        });

        nodeList.forEach((node) => {
          node.childrenList = childrenMap[node.id] || [];
        });

        return childrenMap;
      }

      function processData() {
        if (!data || !data.mocKgNodeDtoList) return;

        initSVG();
        expandedNodes.clear();

        const childrenMap = buildNodeTree(data.mocKgNodeDtoList);
        const rootNodes = childrenMap[-1] || [];
        if (rootNodes.length === 0) return;

        const root = rootNodes[0];
        expandedNodes.add(root.id);

        updateGraph();
      }

      function getVisibleNodesWithLevel(node, level = 0, result = []) {
        const nodeWithLevel = { ...node, level };
        result.push(nodeWithLevel);

        if (
          expandedNodes.has(node.id) &&
          node.childrenList &&
          node.childrenList.length > 0
        ) {
          node.childrenList.forEach((child) => {
            getVisibleNodesWithLevel(child, level + 1, result);
          });
        }

        return result;
      }

      function radialPosition(
        level,
        index,
        total,
        parentX = centerX,
        parentY = centerY,
        parentAngle = 0,
        angleSpan = Math.PI * 2
      ) {
        if (level === 0) {
          return { x: centerX, y: centerY };
        }

        const radius = 280 + (level - 1) * 250;
        const startAngle = parentAngle - angleSpan / 2;
        const angle = startAngle + (index + 0.5) * (angleSpan / total);

        return {
          x: parentX + radius * Math.cos(angle),
          y: parentY + radius * Math.sin(angle),
          targetAngle: angle,
        };
      }

      function updateGraph() {
        const rootNodes = data.mocKgNodeDtoList.filter(
          (n) => n.parentId === -1
        );
        if (rootNodes.length === 0) return;

        const root = rootNodes[0];
        const visibleNodes = getVisibleNodesWithLevel(root);

        // 计算每个节点的层级和理想位置
        const nodesByLevel = {};
        visibleNodes.forEach((node) => {
          if (!nodesByLevel[node.level]) {
            nodesByLevel[node.level] = [];
          }
          nodesByLevel[node.level].push(node);
        });

        // 为每个节点设置初始位置和目标半径
        visibleNodes.forEach((node, i) => {
          const nodesInLevel = nodesByLevel[node.level];
          const indexInLevel = nodesInLevel.indexOf(node);
          const parent =
            node.parentId !== -1
              ? visibleNodes.find((n) => n.id === node.parentId)
              : null;

          const pos = radialPosition(
            node.level,
            indexInLevel,
            nodesInLevel.length,
            parent ? parent.x : centerX,
            parent ? parent.y : centerY
          );

          node.x = pos.x;
          node.y = pos.y;
          node.targetRadius = 280 + node.level * 250;
          node.radius = Math.max(70 / Math.pow(1.5, node.level), 18);
        });

        const links = [];
        visibleNodes.forEach((node) => {
          if (node.parentId !== -1) {
            const parent = visibleNodes.find((n) => n.id === node.parentId);
            if (parent) {
              links.push({ source: parent.id, target: node.id });
            }
          }
        });

        const visibleNodeIds = new Set(visibleNodes.map((n) => n.id));
        const relations = (data.mocKgRelationDtoList || [])
          .filter(
            (rel) =>
              visibleNodeIds.has(rel.fromNodeId) &&
              visibleNodeIds.has(rel.toNodeId)
          )
          .map((rel) => ({
            source: rel.fromNodeId,
            target: rel.toNodeId,
            relationType: rel.relationType,
          }));

        if (simulation) simulation.stop();

        // 创建力导向模拟，保持径向结构
        simulation = d3
          .forceSimulation(visibleNodes)
          .force(
            "link",
            d3
              .forceLink(links)
              .id((d) => d.id)
              .distance(120)
              .strength(0.3)
          )
          .force("charge", d3.forceManyBody().strength(-300))
          .force(
            "collision",
            d3
              .forceCollide()
              .radius((d) => d.radius + 20)
              .strength(0.9)
          )
          .force(
            "radial",
            d3
              .forceRadial((d) => d.targetRadius, centerX, centerY)
              .strength(0.8)
          )
          .force("center", d3.forceCenter(centerX, centerY).strength(0.05))
          .alphaDecay(0.02);

        // 绘制层级连线
        const linkElements = g
          .selectAll(".link")
          .data(links, (d) => `${d.source}-${d.target}`)
          .join("line")
          .attr("class", "link");

        // 绘制关系连线
        const relationElements = g
          .selectAll(".relation-link")
          .data(relations, (d) => `${d.source}-${d.target}`)
          .join("path")
          .attr(
            "class",
            (d) => `relation-link${showRelations ? "" : " hidden"}`
          )
          .attr("marker-end", showRelations ? "url(#arrowhead)" : "");

        // 绘制关系标签
        const relationLabelElements = g
          .selectAll(".relation-label")
          .data(relations, (d) => `${d.source}-${d.target}`)
          .join("text")
          .attr(
            "class",
            (d) => `relation-label${showRelations ? "" : " hidden"}`
          )
          .text("前置");

        // 绘制节点
        const nodeElements = g
          .selectAll(".node")
          .data(visibleNodes, (d) => d.id)
          .join("g")
          .attr("class", "node")
          .call(drag(simulation));

        nodeElements.selectAll("*").remove();

        nodeElements
          .append("circle")
          .attr("r", (d) => d.radius)
          .attr(
            "fill",
            (d) => levelColors[Math.min(d.level, levelColors.length - 1)]
          );

        nodeElements
          .append("text")
          .attr("dy", "0.35em")
          .attr("font-size", (d) => `${Math.max(d.radius / 3.2, 11)}px`)
          .text((d) => {
            const maxLen = Math.floor(d.radius / 4.5);
            return d.nodeName.length > maxLen
              ? d.nodeName.substring(0, maxLen - 1) + "…"
              : d.nodeName;
          });

        nodeElements
          .filter((d) => d.childrenList && d.childrenList.length > 0)
          .append("circle")
          .attr("class", "expand-indicator")
          .attr("cx", (d) => d.radius * 0.7)
          .attr("cy", (d) => -d.radius * 0.7)
          .attr("r", 11)
          .attr("fill", (d) =>
            expandedNodes.has(d.id) ? "#10b981" : "#f59e0b"
          )
          .attr("stroke", "#ffffff")
          .attr("stroke-width", 2.5);

        nodeElements
          .filter((d) => d.childrenList && d.childrenList.length > 0)
          .append("text")
          .attr("x", (d) => d.radius * 0.7)
          .attr("y", (d) => -d.radius * 0.7)
          .attr("dy", "0.35em")
          .attr("text-anchor", "middle")
          .attr("fill", "#ffffff")
          .attr("font-weight", "bold")
          .attr("font-size", "16px")
          .style("pointer-events", "none")
          .text((d) => (expandedNodes.has(d.id) ? "−" : "+"));

        nodeElements.on("click", (event, d) => {
          event.stopPropagation();
          if (d.childrenList && d.childrenList.length > 0) {
            toggleNode(d);
          }
          showDescription(d);
        });

        simulation.on("tick", () => {
          linkElements
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          relationElements.attr("d", (d) => {
            const sourceNode = visibleNodes.find((n) => n.id === d.source);
            const targetNode = visibleNodes.find((n) => n.id === d.target);
            if (!sourceNode || !targetNode) return "";

            const dx = targetNode.x - sourceNode.x;
            const dy = targetNode.y - sourceNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const offsetX = (dx / dist) * targetNode.radius;
            const offsetY = (dy / dist) * targetNode.radius;

            return `M ${sourceNode.x} ${sourceNode.y} L ${
              targetNode.x - offsetX
            } ${targetNode.y - offsetY}`;
          });

          relationLabelElements
            .attr("x", (d) => {
              const sourceNode = visibleNodes.find((n) => n.id === d.source);
              const targetNode = visibleNodes.find((n) => n.id === d.target);
              return sourceNode && targetNode
                ? (sourceNode.x + targetNode.x) / 2
                : 0;
            })
            .attr("y", (d) => {
              const sourceNode = visibleNodes.find((n) => n.id === d.source);
              const targetNode = visibleNodes.find((n) => n.id === d.target);
              return sourceNode && targetNode
                ? (sourceNode.y + targetNode.y) / 2 - 5
                : 0;
            });

          nodeElements.attr("transform", (d) => `translate(${d.x}, ${d.y})`);
        });

        updateStats(visibleNodes.length);
      }

      function toggleNode(nodeData) {
        if (expandedNodes.has(nodeData.id)) {
          expandedNodes.delete(nodeData.id);
          collapseChildren(nodeData.id);
        } else {
          expandedNodes.add(nodeData.id);
        }
        updateGraph();
      }

      function collapseChildren(nodeId) {
        const nodeData = allNodesData[nodeId];
        if (nodeData && nodeData.childrenList) {
          nodeData.childrenList.forEach((child) => {
            expandedNodes.delete(child.id);
            collapseChildren(child.id);
          });
        }
      }

      function expandAll() {
        Object.values(allNodesData).forEach((node) => {
          if (node.childrenList && node.childrenList.length > 0) {
            expandedNodes.add(node.id);
          }
        });
        updateGraph();
      }

      function collapseAll() {
        const root = data.mocKgNodeDtoList.find((n) => n.parentId === -1);
        expandedNodes.clear();
        expandedNodes.add(root.id);
        updateGraph();
      }

      function toggleRelations() {
        showRelations = !showRelations;
        const btn = document.getElementById("relationBtn");
        btn.textContent = showRelations ? "隐藏关系" : "显示关系";
        btn.classList.toggle("active", showRelations);

        d3.selectAll(".relation-link")
          .classed("hidden", !showRelations)
          .attr("marker-end", showRelations ? "url(#arrowhead)" : "");

        d3.selectAll(".relation-label").classed("hidden", !showRelations);
      }

      function showDescription(nodeData) {
        selectedNode = nodeData;
        d3.selectAll(".node").classed("selected", false);
        d3.selectAll(".node")
          .filter((d) => d.id === nodeData.id)
          .classed("selected", true);

        document.getElementById("node-title").textContent = nodeData.nodeName;
        document.getElementById("node-description").textContent =
          nodeData.description || "暂无描述";
        document.getElementById("description-panel").classList.add("show");
      }

      function updateStats(visibleCount) {
        document.getElementById("total-nodes").textContent =
          Object.keys(allNodesData).length;
        document.getElementById("visible-nodes").textContent = visibleCount;
      }

      function drag(simulation) {
        function dragstarted(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
        }

        function dragged(event) {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
        }

        function dragended(event) {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
        }

        return d3
          .drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);
      }
    </script>
  </body>
</html>
